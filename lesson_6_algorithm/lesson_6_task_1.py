"""
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с наиболее эффективным использованием памяти.

Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:

● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;

● написать 3 варианта кода (один у вас уже есть);

● проанализировать 3 варианта и выбрать оптимальный;

● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;

● написать общий вывод: какой из трёх вариантов лучше и почему.

Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили
творчество, фантазию и создали универсальный код для замера памяти.

"""
import sys


number_1 = 32
number_2 = 52


def show(obj):
    print(f'{type(obj)=}, {sys.getsizeof(obj)=}, {obj=}')
    if hasattr(obj, '__iter__'):
        if type(obj) == str:
            return
        if hasattr(obj, 'items'):
            for key, value in obj.items():
                print('--------------------------')
                show(key)
                show(value)
        else:
            for item in obj:
                show(item)


def recur(a, b):
    if a == b:
        return "%4d - %s" % (b, chr(b))
    return str("%4d - %s" % (a, chr(a))) + str(recur(a + 1, b))


str_iter = recur(number_1, number_2)
print(f'Вариант № 1: {sys.getsizeof(show(str_iter))= }')
print('==========================================')


def tuple_iter():
    my_list = []
    for k in range(32, 52):
        my_list.append("%4d - %s" % (k, chr(k)))
    tlp = tuple(my_list)
    return tlp


print(f'Вариант № 2: {sys.getsizeof(show(tuple_iter()))= }')
print('==========================================')

my_dict = {}

for i in range(32, 52):
    my_dict[i] = chr(i)

print(f'Вариант № 3: {sys.getsizeof(show(my_dict))= }')
print('==========================================')

"""
КОММЕНТАРИЙ:
    
type(obj)=<class 'str'>, sys.getsizeof(obj)=217, obj='  32 -    33 - !  34 - "  35 - #  36 - $  37 - %  38 - &  39 - 
\'  40 - (  41 - )  42 - *  43 - +  44 - ,  45 - -  46 - .  47 - /  48 - 0  49 - 1  50 - 2  51 - 3  52 - 4'

Вариант № 1: sys.getsizeof(show(str_iter))= 16
==========================================
type(obj)=<class 'tuple'>, sys.getsizeof(obj)=200, obj=('32, ', '33,!', '34,"', '35,#', '36,$', '37,%', '38,&', "39,'", 
'40,(', '41,)', '42,*', '43,+', '44,,', '45,-', '46,.', '47,/', '48,0', '49,1', '50,2', '51,3')

Вариант № 2: sys.getsizeof(show(tlp))= 16
==========================================
type(obj)=<class 'dict'>, sys.getsizeof(obj)=640, obj={32: ' ', 33: '!', 34: '"', 35: '#', 36: '$', 37: '%', 38: '&', 
39: "'", 40: '(', 41: ')', 42: '*', 43: '+', 44: ',', 45: '-', 46: '.', 47: '/', 48: '0', 49: '1', 50: '2', 51: '3'}

Вариант № 3: sys.getsizeof(show(my_dict))= 16
==========================================
    
ВЫВОД:
   Самый оптимальный вариант для памяти Вариант № 2 через цикл и в кортеж. Кортеж неизменяемый
   а значит памяти выделяется ровно столько сколько нужно на обьект.
   
"""
