# -*- coding: utf-8 -*-
"""practice_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yy8NS4prK2HhVh3wefdPvPyu_-gOvDqs
"""

# Сначала нужно выполнить это 
# !pip install Faker

# цикл вместо дублирования 4 строчек кода
from collections import namedtuple
from random import randint, random
from random import uniform
from faker import Faker
fake = Faker()

all_comp = []
Comp = namedtuple('Comp', 'name, p1, p2, p3, p4, total')
num = randint(2, 10)  # Количество компаний
for i in range(num):
    name = fake.name()
    spam = []
    total = 0
    # p1 = input()
    # p2 = input()
    # p3 = input()
    # p4 = input()
    for j in range(1, 4):
        profit = uniform(0,100)
        spam.append(profit)
        total += profit
    all_comp.append(Comp(name, *spam, sum(spam), total))

for company in all_comp:
    print(company)

"""
Пользователь вводит данные о количестве предприятий,
их наименования и прибыль за квартал для каждого.
Программа должна определить среднюю прибыль и
вывести наименования предприятий, чья прибыль выше среднего.
Отдельно вывести наименования предприятий, чья прибыль ниже среднего.
"""
from collections import deque, namedtuple

PERIOD = 4
Company = namedtuple('Company', ['name', 'quarters', 'profit'])
all_companies = set()

num = randint(2, 10)  # Количество компаний
total_profit = 0
for i in range(1, num + 1):
    profit = 0
    quarters = []
    name = fake.name()  # название предприятия

    for j in range(PERIOD):
        quarters.append(uniform(0,100))
        profit += quarters[j]

    comp = Company(name=name, quarters=tuple(quarters), profit=profit)

    all_companies.add(comp)
    total_profit += profit

average = total_profit / num

print(f'\nСредняя прибыль = {average}')

# вариант 1
print(f'\nПредприятя с прибылью выше среднего:')
for comp in all_companies:
    if comp.profit > average:
        print(f'Компания {comp.name} заработала {comp.profit:5.1f}')
        # Этого нет в задаче, просто пример как можно работать с данными.
        # print(comp.quarters[0])  # так можно получить доступ к нужной четверти.

print(f'\nПредприятя с прибылью ниже среднего:')
for comp in all_companies:
    if comp.profit < average:
        print(f'Компания {comp.name} заработала {comp.profit:5.1f}')

# вывод результат с использованием очереди - вариант 2
print('*' * 50)

sort_comp = deque([None])
for comp in all_companies:
    if comp.profit > average:
        sort_comp.append(comp)
    elif comp.profit < average:
        sort_comp.appendleft(comp)

text = 'меньше'
for comp in sort_comp:
    if comp is None:
        text = 'больше'
    else:
        print(
            f'Компания {comp.name} заработала {text}, чем средняя прибыль - {comp.profit:5.1f}'
        )

"""
2. Написать программу сложения и умножения двух шестнадцатеричных чисел. 
При этом каждое число представляется
как массив, элементы которого это цифры числа.
Например, пользователь ввёл A2 и C4F. Сохранить их как [‘A’, ‘2’]
и [‘C’, ‘4’, ‘F’] соответственно. 
Сумма чисел из примера: [‘C’, ‘F’, ‘1’], 
произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].
"""
from collections import deque

BASE = 16

HEX_NUMBERS = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',
               'D', 'E', 'F')

DEC_NUMBERS = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3,
    '4': 4,
    '5': 5,
    '6': 6,
    '7': 7,
    '8': 8,
    '9': 9,
    'A': 10,
    'B': 11,
    'C': 12,
    'D': 13,
    'E': 14,
    'F': 15
}


def sum_hex(first, second):
    """
    Изменяемые объекты передаются по ссылке
    Используем копию, чтобы не ломать оригинал
    """
    first = first.copy()
    second = second.copy()

    if len(second) > len(first):
        first, second = second, first

    second.extendleft('0' * (len(first) - len(second)))

    result = deque()
    overflow = 0
    while len(first) != 0:
        first_num = DEC_NUMBERS[first.pop()]
        second_num = DEC_NUMBERS[second.pop()]

        result_num = first_num + second_num + overflow

        if result_num >= BASE:
            overflow = 1
            result_num -= BASE
        else:
            overflow = 0

        result.appendleft(HEX_NUMBERS[result_num])

    if overflow == 1:  # is_overflow = True or False
        result.appendleft('1')

    return result


def mult_hex(first, second):
    first = first.copy()
    second = second.copy()

    if len(second) > len(first):
        first, second = second, first

    second.extendleft('0' * (len(first) - len(second)))
    result = deque('0')

    while len(second) != 0:
        second_num = DEC_NUMBERS[second.pop()]

        spam = deque('0')
        for _ in range(second_num):
            spam = sum_hex(spam, first)

        spam.extend('0' * (len(first) - len(second) - 1))
        result = sum_hex(result, spam)

    return result


a = deque(input('Введите первое число в hex формате: ').upper())
b = deque(input('Введите второе число в hex формате: ').upper())

# плохой подход на два балла в рамках текущего задания
# z = hex(int('a2', 16) + int('c4f', 16))
print(f'{list(a)} + {list(b)} = {list(sum_hex(a, b))}')
# специально убрал список, чтобы показать как хранится
print(f'{a} * {b} = {mult_hex(a, b)}')

"""
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
"""
import sys


class SumMemory:
    def __init__(self):
        """
        _sum_memory - общее количество занятой памяти
        _types - словарь вида {'type': [count, size]}
        """
        self._sum_memory = 0
        self._types = {}

    def extend(self, *args):
        for obj in args:
            print(obj)
            self._add(obj)


    def _add(self, obj):
        print(obj)
        spam = sys.getsizeof(obj)
        self._sum_memory += spam
        eggs = type(obj)
        if eggs in self._types:
            self._types[eggs][0] += 1
            self._types[eggs][1] += spam
        else:
            self._types[eggs] = [1, spam]
            # self._types[eggs][1] = spam

        if hasattr(obj, '__iter__'):
            if hasattr(obj, 'items'):
                for key, value in obj.items():
                    self._add(key)
                    self._add(value)
            elif not isinstance(obj, str):
                for item in obj:
                    self._add(item)

    def __str__(self):
        return f'\nПеременные заняли в сумме {self._sum_memory} байт \n'.join([f'Объекты класса {key} '
                           f'в количестве {value[0]} '
                           f'заняли {value[1]} байт '
                           for key, value in self._types.items()])


a = random.uniform(0, 9)
print(f'{a = :.2f}')