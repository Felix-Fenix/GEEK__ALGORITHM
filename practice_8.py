# -*- coding: utf-8 -*-
"""practice_8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R_wmnnRW4z4zb8AcoJSHUcY9bMDeF7Js
"""

# https://colab.research.google.com/drive/1R_wmnnRW4z4zb8AcoJSHUcY9bMDeF7Js?usp=sharing

"""### 1 задача: Пузырек"""

"""
Отсортировать по убыванию методом «пузырька» одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100).
Вывести на экран исходный и отсортированный массивы.
"""

import random
from copy import deepcopy

SIZE = 10
LIMIT = 100
init_data = [random.randrange(-LIMIT, LIMIT) for _ in range(SIZE)]
print(f'Первоначальный массив {init_data}')


def bubble_sort(array, reverse=False):
    sign = int(reverse) * 2 - 1
    n = 1

    while n < len(array):
        is_sorted = True
        for i in range(len(array) - n):
            if array[i] * sign < array[i + 1] * sign:
                array[i], array[i + 1] = array[i + 1], array[i]
                is_sorted = False
        if is_sorted:
            break
        n += 1
        # print(array)

data = deepcopy(init_data)
bubble_sort(data, reverse=True)
print(data)

# test
for i in range(100):
    init_data = [random.randrange(-LIMIT, LIMIT) for _ in range(SIZE)]
    print(init_data)
    data = deepcopy(init_data)
    bubble_sort(data, reverse=True)
    assert data == sorted(init_data, reverse=True)
print('test OK')

"""### 2 задача: Слияние"""

"""
Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
заданный случайными числами на промежутке [0; 50).
Выведите на экран исходный и отсортированный массивы.
"""

def merge_sort(array):
    if len(array) <= 1:
        return array

    left = merge_sort(array[:len(array) // 2])
    right = merge_sort(array[len(array) // 2:])
    i = j = 0

    while len(left) > i and len(right) > j:
        if left[i] < right[j]:
            array[i + j] = left[i]
            i += 1
        else:
            array[i + j] = right[j]
            j += 1

    while len(left) > i:
        array[i + j] = left[i]
        i += 1
    while len(right) > j:
        array[i + j] = right[j]
        j += 1
    
    print([f'{i:.1f}' for i in array])  # для наглядности
    return array

SIZE = 10
LIMIT = 50  # [49.0, 50.0)
data = [random.uniform(0, LIMIT) for _ in range(SIZE)]
# if data[-1] == 50:  # если не доверяете uniform
#     data.pop()
#  round для простоты визуальной проверки
data = [round(random.uniform(0, LIMIT), 2) for _ in range(SIZE)]
print(data)
merge_sort(data)
print(data)


SIZE = 4
LIMIT = 100
data = [random.randrange(0, LIMIT) for _ in range(2 * SIZE + 1)]

"""3). Массив размером 2m + 1, где m — натуральное число, заполнен случайным 
образом. Найдите в массиве медиану. Медианой называется элемент ряда, 
делящий его на две равные части: в одной находятся элементы, которые 
не меньше медианы, в другой — не больше медианы.

Примечание: задачу можно решить без сортировки исходного массива. Но если это 
слишком сложно, используйте метод сортировки, который не рассматривался на 
уроках (сортировка слиянием также недопустима).
"""
# вариант 1
def median_square(array):
    for i in range(len(array)):
        smaller = equal = bigger = 0
        for j in range(len(array)):
            if array[i] < array[j]:
                smaller += 1
            elif array[i] > array[j]:
                bigger += 1
            else:
                equal += 1
        equal -= 1

        if smaller == bigger or smaller == equal + bigger or bigger == equal + smaller or \
                (equal > 1 and abs(bigger - smaller) < equal):
            return array[i]

print(data)
print(f'mediana_square = {median_square(data)}')
print(data)
print(sorted(data))

# вариант 2
def partition(array, pivot):
    smaller = []
    equally = []
    bigger = []
    for item in array:
        if item < pivot:
            smaller.append(item)
        elif item > pivot:
            bigger.append(item)
        else:
            equally.append(item)
    return smaller, equally, bigger

def top_key(array, key):
    pivot = array[random.randrange(len(array))]
    left, middle, right = partition(array, pivot)

    if len(left) == key:
        return left
    if len(left) < key <= len(left) + len(middle):
        return middle
    if len(left) > key:
        return top_key(left, key)
    return top_key(right, key - len(left) - len(middle))

def median(array):
    result_list = top_key(array, len(array) // 2 + 1)
    return max(result_list)

print(data)
print(f'mediana = {median(data)}')
print(data)
print(sorted(data))

# вариант 3
import statistics
print(data)
print(f'mediana = {statistics.median(data)}')
print(sorted(data))

"""### Примеры урока"""


from binarytree import tree, bst

class MyNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f'{self.value}=>{self.left}-{self.right}'

c = MyNode(42)
c.left = MyNode(12)
c.right = MyNode('Text')
c.left.right = MyNode(3)
print(c)

bin_t = bst(height=3, is_perfect=True)
print(bin_t)

num = 50

def go(bin_tree, number, path='') -> str:
    if number == bin_tree.value:
        return f'Число найдено по пути: {path}'

    if number < bin_tree.value and bin_tree.left is not None:
        return go(bin_tree.left, number, path=f'{path}\nШаг влево, {bin_tree.value}')
    if number > bin_tree.value and bin_tree.right is not None:
        return go(bin_tree.right, number, path=f'{path}\nШаг вправо, {bin_tree.value}')
    return f'Число {number} отсутсвует'

print(go(bin_t, num))

h_list = [None] * 26

def my_hash(value):
    hash_ = ord(value[0]) - ord('a')
    h_list[hash_] = value
    print(h_list)

a = 'apple'
# my_hash(a)
b = 'banana'
# my_hash(b)
c = 'avoca'
# my_hash(c)

print(4567 == 4*10**3 + 5*10**2 + 6*10**1 + 7*10**0)

def my_hash_2(value):
    letter = 26
    hash_ = 0
    size = 10_0_0_0
    for index, char in enumerate(value):
        hash_ += (ord(char) - ord('a') + 1) * letter ** index
    return hash_ % size

print('---------------')
print(my_hash_2(a))
print(my_hash_2(b))
print(my_hash_2(c))

print(hash('Hello world!'))

import hashlib

# print(hashlib.sha1(b'Hello world!').hexdigest() == hashlib.sha1(b'Hello world!').hexdigest())
print(hashlib.sha1('Hello world!ж'.encode('utf-8')).hexdigest())
print(hashlib.sha256('Hello world!ж'.encode('utf-8')).hexdigest())
print(hashlib.sha512('Hello world!ж'.encode('utf-8')).hexdigest())

print(hashlib.md5('qwerty'.encode('utf-8')).hexdigest())

import hmac

print(hmac.new(key=b'adfagdasg', msg=b'Hello', digestmod=hashlib.md5).hexdigest())